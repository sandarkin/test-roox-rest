Дана модель данных:

**Customer** - абонент.  
Имеет атрибуты id, ФИО, баланс, статус (активен, заблокирован), логин, пароль. Типы данных, ограничения выбираете сами исходя из своего опыта.

**PartnerMapping** - привязка аккаунта абонента к партнерскому сервису.
В качестве партнерского сервиса может выступать, например, социальная сеть.  
Атрибуты: id привязки, идентификатор партнера (например, идентификатор конкретного приложения в социальной сети Facebook), идентификатор аккаунта абонента в этой партнерской системе (например, id профиля абонента в соцсети), ФИО абонента в партнерском сервисе, аватар пользователя в партнерском сервисе. Типы данных, ограничения выбираете сами исходя из своего опыта.

Отношение Customer - PartnerMapping 1 ко многим.

Идентификаторы всей объектной модели - сквозные. То есть идентификатор уникально определяет объект в БД, не может быть объектов двух разных классов с одним идентификатором.

Требуется:

- создать веб приложение на Java, предоставляющее REST API, который позволяет работать с абонентами и их привязками. Операции - Customer - только read. PartnerMapping - стандартный CRUD.

- адресация абонента в URL может быть на по его id, так и по литералу @me - в таком случае используется "текущий абонент", полученный со слоя аутентификации.

- данные хранить в реляционной БД на выбор (допустимо использование "in memory" БД)

- абонент может работать только со своими данными. Токен авторизации передается в заголовке Authorization (предполагается, что абонент ранее аутентифицировался и в результате ему выдали токен доступа к API).

Формат заголовка Authorization: Bearer <id абонента>

Способ адресации ресурсов - на выбор, но в адресе предпочтительнее отразить реляционную структуру данных. Все ресурсы "идут" от абонента.

Способ возвращения ошибок - на выбор.

Для написания слоев контроллеров и сервисов использовать фреймворк Spring MVC Для слоя DAO использовать JPA, по желанию spring data.

Приложение должно упаковываться в war-файл (для spring-boot можно jar-файл)

Результатом вашей работы должен быть исходный код с комментариями на public классы и методы и war-файл для деплоя на сервлет-контейнере (или jar файл для spring-boot).

Сборка желательно с использованием gradle или maven.

Большим плюсом считается наличие unit-тестов, JavaDocs. Вернее, оформляйте проект так, как делаете это обычно в команде. Документация и тесты не самоцель для нас, а инструмент.
